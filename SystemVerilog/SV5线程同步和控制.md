# SystemVerilog —— 第五章 线程的控制和同步
 ## 5.1 线程控制
 - 时序控制：#10
### 5.1.1 并行线程 
- fork  join：所有并行的线程结束后才会继续执行下一步
- fork  join_any：任何一个线程结束后就会继续执行
- fork  join_none：直接继续执行，而不用等子线程（同一时间，先执行线程后面的语句）
- disable fork：关闭当前的线程或指定TAG的线程
	- 父线程disable掉后，子线程也会消失
- wait fork：等待子线程全部完成再退出

### 5.1.2 串行线程
- 串行线程：begin end

## 5.2 线程间的通信（IPC, Interprocess Communication）
### 5.2.1 事件（event）
- 声明一个event类型的变量，并触发它
- event是对象但是不需要用new来创建
	- event e1;
- event来控制进程的执行
- 通过->来触发事件
	- -> e1;

- 其他等待该事件的进程可以通过@操作符或者wait()来检查
	- @e1
		- 会阻塞，直到触发事件，边沿敏感
		- 适用于多次触发

	- wait(e1.triggered)
		- 电平敏感
		- 如果事件在当前时刻被触发，则不会引起阻塞，否则会一直等到触发为止
		- 相比与@而言，可以避免在相同时刻触发event带来的竞争问题，但是同样无法捕捉已经触发，在后续才等待事件的阻塞情况

- wait_order()
	- 可以使得进程保持等待，直到在参数列表中的事件按照顺序从左到右依次完成
	- 如果参数列表中的事件触发，但没有按照顺序，那么等待操作失败

### 5.2.2 旗语（semaphore）
- 旗语可以实现对同一资源的访问控制
- 创建旗语，并为其分配钥匙的方式如下
	- semaphore sm;
sm = new(1);
- 创建一个具有固定钥匙数量的旗语
	- new (N = 0)
- 从旗语那里获取一个或多个钥匙（阻塞型）
	- get (N= 1)
		- get()默认为1把钥匙
		- 如果指定数量的钥匙可用，则该方法返回并继续执行
		- 如果指定数量的钥匙不可用，进程将阻塞，直到钥匙数目充足
		- 旗语的等待队列是先进先出（FIFO），即先排队等待旗语的先得到钥匙

- 将一个或多个钥匙返回到旗语中
	- put (N = 1)

- 尝试获取一个或多个钥匙而不会阻塞（非阻塞型）
	- try_get (N = 1)
		- 用于从信号量中获取指定数量的钥匙，但不会被阻塞
		- try_get() 默认值为1
		- 如果指定数量的钥匙可以，则方法返回1并继续执行
		- 如果指定数量的钥匙不可用，则该方法返回0


- 同一时间只能有一个线程拿到钥匙

### 5.2.3 信箱（mailbox）

- 可以使得进程之间的信息得以交换，数据可以由一个进程写入信箱，再由另一个进程获得
- 信箱在创建时可以限制其容量，或者不限制
- 当信箱容量写满时，后续再写入的动作会被挂起，直到信箱的数据从中读取，使得信箱有空间以后才能继续写入
	- 信箱为满，put()会被阻塞，信箱为空，get()会被阻塞

- 不限制容量的信箱则不会挂起写入信箱的动作
- 信箱的内建方法
- 创建信箱：
	- new();
	- 可以限制大小，默认为0，为无穷大

- 将信息写入信箱：put();
- 试着写入信箱但不会阻塞：try_put();
- 获取信箱
	- get()获取数据同时会取出数据
	- peek()获取数据时不会取出数据，获取信箱里数据的拷贝而不移除他
- 试着从信箱取出数据但不会阻塞
	- try_get();
	- try_peek();
- 获取信箱信箱的数目
	- num();
- 限制mailbox存储的数据类型
	- mailbox#(int)

### 5.2.4 三种通信方法比较
- event：最小信息量的触发，即单一的通知功能。可以用来做事件的触发，也可以多个event组合起来用作线程之间的同步
- semaphore：共享资源的安全卫生。如果多线程间要对某一公共资源进行访问，即可以使用这个要素
- mailbox：精小的SV原生FIFO。在线程之间做数据通信或内部数据缓存时可以考虑使用此要素


## 5.3 类型转化
- 静态类型转化
	- 静态转换操作符不对转换值进行检查
	- 转换时指定目标类型，并在要转换的表达式前加上单引号
- 动态类型转化
	- $cast(a,b);
	- 将b转化为a类型
